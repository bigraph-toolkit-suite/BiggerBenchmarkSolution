#using "metamodel_graph.gm"
pattern nac_NodesWithoutSites(src:BNode, var validChildCount: int) {
    negative {
        if { adjacentIncoming(src, bPrnt).size() != validChildCount; }
    }
}

rule es_0_1 {
r0:Node; v6:SLck; v7:SLckRef; v7_p0:BPort; v8:Mvmt; v9:Locale; v9_p0:BPort; v10:OccupiedBy; v12:ID; v11:Robot; v11_p0:BPort; v14:SLck; v13:N1; v0:Locale; v0_p0:BPort; v16:Mvmt; v1:Route; v1_p0:BPort; v15:SLckRef; v15_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N0; 
v0 -c0:bPrnt-> r0;
v9 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v9_p0 -c5:bNode-> v9;
v10 -c6:bPrnt-> v9;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v11 -c9:bPrnt-> v10;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v8 -c13:bPrnt-> v3;
v11_p0 -c14:bNode-> v11;
v12 -c15:bPrnt-> v11;
v14 -c16:bPrnt-> v11;
v16 -c17:bPrnt-> v11;
v5 -c18:bPrnt-> v4;
v7 -c19:bPrnt-> v6;
v13 -c20:bPrnt-> v12;
v15 -c21:bPrnt-> v14;
v7_p0 -c22:bNode-> v7;
v15_p0 -c23:bNode-> v15;
pat0:nac_NodesWithoutSites(v6, 1);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v8, 0);
pat3:nac_NodesWithoutSites(v10, 1);
pat4:nac_NodesWithoutSites(v12, 1);
pat5:nac_NodesWithoutSites(v14, 1);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v16, 0);
pat8:nac_NodesWithoutSites(v1, 0);
pat9:nac_NodesWithoutSites(v15, 0);
pat10:nac_NodesWithoutSites(v2, 1);
pat11:nac_NodesWithoutSites(v4, 1);
pat12:nac_NodesWithoutSites(v5, 0);
if { v7_p0.ix == 0; }
if { v9_p0.ix == 0; }
if { v11_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v15_p0.ix == 0; }
if { v3_p0.ix == 0; }

right:BLink;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
e0:BEdge;
v7_p0 -:bLink-> e0;
v15_p0 -:bLink-> e0;
left:BLink;
v0_p0 -:bLink-> left;
rn1:BLink;
v11_p0 -:bLink-> rn1;
rn0:BLink;
v3_p0 -:bLink-> rn0;
replace {
v6 -c12-> v3;
v8 -c13-> v3;
v9 -c1-> r0;
v9_p0 -c5-> v9;
v10 -c6-> v9;
v11 -c9-> v10;
v11_p0 -c14-> v11;
v13 -c20-> v12;
v12 -c15-> v11;
v16 -c17-> v11;
v14 -c16-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
v3_p0 -:bLink-> rn0;
v0_p0 -:bLink-> left;
v11_p0 -:bLink-> rn1;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v16, v1, v15, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v9 -> v9, 
v11 -> v11, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule es_0_2 {
r0:Node; v6:SLck; v7:SLckRef; v7_p0:BPort; v8:Mvmt; v9:Locale; v9_p0:BPort; v10:OccupiedBy; v12:ID; v11:Robot; v11_p0:BPort; v14:SLck; v13:N2; v0:Locale; v0_p0:BPort; v16:Mvmt; v1:Route; v1_p0:BPort; v15:SLckRef; v15_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N0; 
v0 -c0:bPrnt-> r0;
v9 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v9_p0 -c5:bNode-> v9;
v10 -c6:bPrnt-> v9;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v11 -c9:bPrnt-> v10;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v8 -c13:bPrnt-> v3;
v11_p0 -c14:bNode-> v11;
v12 -c15:bPrnt-> v11;
v14 -c16:bPrnt-> v11;
v16 -c17:bPrnt-> v11;
v5 -c18:bPrnt-> v4;
v7 -c19:bPrnt-> v6;
v13 -c20:bPrnt-> v12;
v15 -c21:bPrnt-> v14;
v7_p0 -c22:bNode-> v7;
v15_p0 -c23:bNode-> v15;
pat0:nac_NodesWithoutSites(v6, 1);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v8, 0);
pat3:nac_NodesWithoutSites(v10, 1);
pat4:nac_NodesWithoutSites(v12, 1);
pat5:nac_NodesWithoutSites(v14, 1);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v16, 0);
pat8:nac_NodesWithoutSites(v1, 0);
pat9:nac_NodesWithoutSites(v15, 0);
pat10:nac_NodesWithoutSites(v2, 1);
pat11:nac_NodesWithoutSites(v4, 1);
pat12:nac_NodesWithoutSites(v5, 0);
if { v7_p0.ix == 0; }
if { v9_p0.ix == 0; }
if { v11_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v15_p0.ix == 0; }
if { v3_p0.ix == 0; }

right:BLink;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
e0:BEdge;
v7_p0 -:bLink-> e0;
v15_p0 -:bLink-> e0;
rn2:BLink;
v11_p0 -:bLink-> rn2;
left:BLink;
v0_p0 -:bLink-> left;
rn0:BLink;
v3_p0 -:bLink-> rn0;
replace {
v6 -c12-> v3;
v8 -c13-> v3;
v9 -c1-> r0;
v9_p0 -c5-> v9;
v10 -c6-> v9;
v11 -c9-> v10;
v11_p0 -c14-> v11;
v13 -c20-> v12;
v12 -c15-> v11;
v16 -c17-> v11;
v14 -c16-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v11_p0 -:bLink-> rn2;
v3_p0 -:bLink-> rn0;
v0_p0 -:bLink-> left;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v16, v1, v15, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v9 -> v9, 
v11 -> v11, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule es_1_2 {
r0:Node; v6:SLck; v7:SLckRef; v7_p0:BPort; v8:Mvmt; v9:Locale; v9_p0:BPort; v10:OccupiedBy; v12:ID; v11:Robot; v11_p0:BPort; v14:SLck; v13:N2; v0:Locale; v0_p0:BPort; v16:Mvmt; v1:Route; v1_p0:BPort; v15:SLckRef; v15_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N1; 
v0 -c0:bPrnt-> r0;
v9 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v9_p0 -c5:bNode-> v9;
v10 -c6:bPrnt-> v9;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v11 -c9:bPrnt-> v10;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v8 -c13:bPrnt-> v3;
v11_p0 -c14:bNode-> v11;
v12 -c15:bPrnt-> v11;
v14 -c16:bPrnt-> v11;
v16 -c17:bPrnt-> v11;
v5 -c18:bPrnt-> v4;
v7 -c19:bPrnt-> v6;
v13 -c20:bPrnt-> v12;
v15 -c21:bPrnt-> v14;
v7_p0 -c22:bNode-> v7;
v15_p0 -c23:bNode-> v15;
pat0:nac_NodesWithoutSites(v6, 1);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v8, 0);
pat3:nac_NodesWithoutSites(v10, 1);
pat4:nac_NodesWithoutSites(v12, 1);
pat5:nac_NodesWithoutSites(v14, 1);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v16, 0);
pat8:nac_NodesWithoutSites(v1, 0);
pat9:nac_NodesWithoutSites(v15, 0);
pat10:nac_NodesWithoutSites(v2, 1);
pat11:nac_NodesWithoutSites(v4, 1);
pat12:nac_NodesWithoutSites(v5, 0);
if { v7_p0.ix == 0; }
if { v9_p0.ix == 0; }
if { v11_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v15_p0.ix == 0; }
if { v3_p0.ix == 0; }

left:BLink;
v0_p0 -:bLink-> left;
right:BLink;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
e0:BEdge;
v7_p0 -:bLink-> e0;
v15_p0 -:bLink-> e0;
rn1:BLink;
v3_p0 -:bLink-> rn1;
rn2:BLink;
v11_p0 -:bLink-> rn2;
replace {
v6 -c12-> v3;
v8 -c13-> v3;
v9 -c1-> r0;
v9_p0 -c5-> v9;
v10 -c6-> v9;
v11 -c9-> v10;
v11_p0 -c14-> v11;
v13 -c20-> v12;
v12 -c15-> v11;
v16 -c17-> v11;
v14 -c16-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
v0_p0 -:bLink-> left;
v3_p0 -:bLink-> rn1;
v11_p0 -:bLink-> rn2;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v16, v1, v15, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v9 -> v9, 
v11 -> v11, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule es_0_3 {
r0:Node; v6:SLck; v7:SLckRef; v7_p0:BPort; v8:Mvmt; v9:Locale; v9_p0:BPort; v10:OccupiedBy; v12:ID; v11:Robot; v11_p0:BPort; v14:SLck; v13:N3; v0:Locale; v0_p0:BPort; v16:Mvmt; v1:Route; v1_p0:BPort; v15:SLckRef; v15_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N0; 
v0 -c0:bPrnt-> r0;
v9 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v9_p0 -c5:bNode-> v9;
v10 -c6:bPrnt-> v9;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v11 -c9:bPrnt-> v10;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v8 -c13:bPrnt-> v3;
v11_p0 -c14:bNode-> v11;
v12 -c15:bPrnt-> v11;
v14 -c16:bPrnt-> v11;
v16 -c17:bPrnt-> v11;
v5 -c18:bPrnt-> v4;
v7 -c19:bPrnt-> v6;
v13 -c20:bPrnt-> v12;
v15 -c21:bPrnt-> v14;
v7_p0 -c22:bNode-> v7;
v15_p0 -c23:bNode-> v15;
pat0:nac_NodesWithoutSites(v6, 1);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v8, 0);
pat3:nac_NodesWithoutSites(v10, 1);
pat4:nac_NodesWithoutSites(v12, 1);
pat5:nac_NodesWithoutSites(v14, 1);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v16, 0);
pat8:nac_NodesWithoutSites(v1, 0);
pat9:nac_NodesWithoutSites(v15, 0);
pat10:nac_NodesWithoutSites(v2, 1);
pat11:nac_NodesWithoutSites(v4, 1);
pat12:nac_NodesWithoutSites(v5, 0);
if { v7_p0.ix == 0; }
if { v9_p0.ix == 0; }
if { v11_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v15_p0.ix == 0; }
if { v3_p0.ix == 0; }

rn0:BLink;
v3_p0 -:bLink-> rn0;
e0:BEdge;
v7_p0 -:bLink-> e0;
v15_p0 -:bLink-> e0;
left:BLink;
v0_p0 -:bLink-> left;
rn3:BLink;
v11_p0 -:bLink-> rn3;
right:BLink;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
replace {
v6 -c12-> v3;
v8 -c13-> v3;
v9 -c1-> r0;
v9_p0 -c5-> v9;
v10 -c6-> v9;
v11 -c9-> v10;
v11_p0 -c14-> v11;
v13 -c20-> v12;
v12 -c15-> v11;
v16 -c17-> v11;
v14 -c16-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v0_p0 -:bLink-> left;
v11_p0 -:bLink-> rn3;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
v3_p0 -:bLink-> rn0;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v16, v1, v15, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v9 -> v9, 
v11 -> v11, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule es_1_3 {
r0:Node; v6:SLck; v7:SLckRef; v7_p0:BPort; v8:Mvmt; v9:Locale; v9_p0:BPort; v10:OccupiedBy; v12:ID; v11:Robot; v11_p0:BPort; v14:SLck; v13:N3; v0:Locale; v0_p0:BPort; v16:Mvmt; v1:Route; v1_p0:BPort; v15:SLckRef; v15_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N1; 
v0 -c0:bPrnt-> r0;
v9 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v9_p0 -c5:bNode-> v9;
v10 -c6:bPrnt-> v9;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v11 -c9:bPrnt-> v10;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v8 -c13:bPrnt-> v3;
v11_p0 -c14:bNode-> v11;
v12 -c15:bPrnt-> v11;
v14 -c16:bPrnt-> v11;
v16 -c17:bPrnt-> v11;
v5 -c18:bPrnt-> v4;
v7 -c19:bPrnt-> v6;
v13 -c20:bPrnt-> v12;
v15 -c21:bPrnt-> v14;
v7_p0 -c22:bNode-> v7;
v15_p0 -c23:bNode-> v15;
pat0:nac_NodesWithoutSites(v6, 1);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v8, 0);
pat3:nac_NodesWithoutSites(v10, 1);
pat4:nac_NodesWithoutSites(v12, 1);
pat5:nac_NodesWithoutSites(v14, 1);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v16, 0);
pat8:nac_NodesWithoutSites(v1, 0);
pat9:nac_NodesWithoutSites(v15, 0);
pat10:nac_NodesWithoutSites(v2, 1);
pat11:nac_NodesWithoutSites(v4, 1);
pat12:nac_NodesWithoutSites(v5, 0);
if { v7_p0.ix == 0; }
if { v9_p0.ix == 0; }
if { v11_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v15_p0.ix == 0; }
if { v3_p0.ix == 0; }

e0:BEdge;
v7_p0 -:bLink-> e0;
v15_p0 -:bLink-> e0;
right:BLink;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
left:BLink;
v0_p0 -:bLink-> left;
rn1:BLink;
v3_p0 -:bLink-> rn1;
rn3:BLink;
v11_p0 -:bLink-> rn3;
replace {
v6 -c12-> v3;
v8 -c13-> v3;
v9 -c1-> r0;
v9_p0 -c5-> v9;
v10 -c6-> v9;
v11 -c9-> v10;
v11_p0 -c14-> v11;
v13 -c20-> v12;
v12 -c15-> v11;
v16 -c17-> v11;
v14 -c16-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v11_p0 -:bLink-> rn3;
v0_p0 -:bLink-> left;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
v3_p0 -:bLink-> rn1;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v16, v1, v15, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v9 -> v9, 
v11 -> v11, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule es_2_3 {
r0:Node; v6:SLck; v7:SLckRef; v7_p0:BPort; v8:Mvmt; v9:Locale; v9_p0:BPort; v10:OccupiedBy; v12:ID; v11:Robot; v11_p0:BPort; v14:SLck; v13:N3; v0:Locale; v0_p0:BPort; v16:Mvmt; v1:Route; v1_p0:BPort; v15:SLckRef; v15_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N2; 
v0 -c0:bPrnt-> r0;
v9 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v9_p0 -c5:bNode-> v9;
v10 -c6:bPrnt-> v9;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v11 -c9:bPrnt-> v10;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v8 -c13:bPrnt-> v3;
v11_p0 -c14:bNode-> v11;
v12 -c15:bPrnt-> v11;
v14 -c16:bPrnt-> v11;
v16 -c17:bPrnt-> v11;
v5 -c18:bPrnt-> v4;
v7 -c19:bPrnt-> v6;
v13 -c20:bPrnt-> v12;
v15 -c21:bPrnt-> v14;
v7_p0 -c22:bNode-> v7;
v15_p0 -c23:bNode-> v15;
pat0:nac_NodesWithoutSites(v6, 1);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v8, 0);
pat3:nac_NodesWithoutSites(v10, 1);
pat4:nac_NodesWithoutSites(v12, 1);
pat5:nac_NodesWithoutSites(v14, 1);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v16, 0);
pat8:nac_NodesWithoutSites(v1, 0);
pat9:nac_NodesWithoutSites(v15, 0);
pat10:nac_NodesWithoutSites(v2, 1);
pat11:nac_NodesWithoutSites(v4, 1);
pat12:nac_NodesWithoutSites(v5, 0);
if { v7_p0.ix == 0; }
if { v9_p0.ix == 0; }
if { v11_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v15_p0.ix == 0; }
if { v3_p0.ix == 0; }

right:BLink;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
rn3:BLink;
v11_p0 -:bLink-> rn3;
left:BLink;
v0_p0 -:bLink-> left;
rn2:BLink;
v3_p0 -:bLink-> rn2;
e0:BEdge;
v7_p0 -:bLink-> e0;
v15_p0 -:bLink-> e0;
replace {
v6 -c12-> v3;
v8 -c13-> v3;
v9 -c1-> r0;
v9_p0 -c5-> v9;
v10 -c6-> v9;
v11 -c9-> v10;
v11_p0 -c14-> v11;
v13 -c20-> v12;
v12 -c15-> v11;
v16 -c17-> v11;
v14 -c16-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v3_p0 -:bLink-> rn2;
v9_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
v0_p0 -:bLink-> left;
v11_p0 -:bLink-> rn3;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v16, v1, v15, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v9 -> v9, 
v11 -> v11, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule ss_1_0 {
r0:Node; v6:SLck; v7:Mvmt; v8:Locale; v8_p0:BPort; v9:OccupiedBy; v10:Robot; v10_p0:BPort; v12:N0; v11:ID; v14:Mvmt; v13:SLck; v0:Locale; v0_p0:BPort; v1:Route; v1_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N1; 
v0 -c0:bPrnt-> r0;
v8 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v8_p0 -c5:bNode-> v8;
v9 -c6:bPrnt-> v8;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v10 -c9:bPrnt-> v9;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v7 -c13:bPrnt-> v3;
v10_p0 -c14:bNode-> v10;
v11 -c15:bPrnt-> v10;
v13 -c16:bPrnt-> v10;
v14 -c17:bPrnt-> v10;
v5 -c18:bPrnt-> v4;
v12 -c19:bPrnt-> v11;
pat0:nac_NodesWithoutSites(v6, 0);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v9, 1);
pat3:nac_NodesWithoutSites(v12, 0);
pat4:nac_NodesWithoutSites(v11, 1);
pat5:nac_NodesWithoutSites(v14, 0);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v1, 0);
pat8:nac_NodesWithoutSites(v2, 1);
pat9:nac_NodesWithoutSites(v4, 1);
pat10:nac_NodesWithoutSites(v5, 0);
if { v8_p0.ix == 0; }
if { v10_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v3_p0.ix == 0; }

rn1:BLink;
v3_p0 -:bLink-> rn1;
right:BLink;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
rn0:BLink;
v10_p0 -:bLink-> rn0;
left:BLink;
v0_p0 -:bLink-> left;
replace {
v6 -c12-> v3;
v7_ef07544:SLckRef;
v7_ef07544 -:bPrnt-> v6;
v7_ef07544_p0:BPort;
v7_ef07544_p0 -c20:bNode-> v7_ef07544;
v7 -c13-> v3;
v8 -c1-> r0;
v8_p0 -c5-> v8;
v9 -c6-> v8;
v11 -c15-> v10;
v10 -c9-> v9;
v10_p0 -c14-> v10;
v13 -c16-> v10;
v12 -c19-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v14 -c17-> v10;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v15_b5fd659:SLckRef;
v15_b5fd659 -:bPrnt-> v13;
v15_b5fd659_p0:BPort;
v15_b5fd659_p0 -c21:bNode-> v15_b5fd659;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v10_p0 -:bLink-> rn0;
v3_p0 -:bLink-> rn1;
e0_ebea863:BEdge;
v7_ef07544_p0 -:bLink-> e0_ebea863;
v15_b5fd659_p0 -:bLink-> e0_ebea863;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
v0_p0 -:bLink-> left;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v1, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v8 -> v8, 
v10 -> v10, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule ss_2_0 {
r0:Node; v6:SLck; v7:Mvmt; v8:Locale; v8_p0:BPort; v9:OccupiedBy; v10:Robot; v10_p0:BPort; v12:N0; v11:ID; v14:Mvmt; v13:SLck; v0:Locale; v0_p0:BPort; v1:Route; v1_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N2; 
v0 -c0:bPrnt-> r0;
v8 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v8_p0 -c5:bNode-> v8;
v9 -c6:bPrnt-> v8;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v10 -c9:bPrnt-> v9;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v7 -c13:bPrnt-> v3;
v10_p0 -c14:bNode-> v10;
v11 -c15:bPrnt-> v10;
v13 -c16:bPrnt-> v10;
v14 -c17:bPrnt-> v10;
v5 -c18:bPrnt-> v4;
v12 -c19:bPrnt-> v11;
pat0:nac_NodesWithoutSites(v6, 0);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v9, 1);
pat3:nac_NodesWithoutSites(v12, 0);
pat4:nac_NodesWithoutSites(v11, 1);
pat5:nac_NodesWithoutSites(v14, 0);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v1, 0);
pat8:nac_NodesWithoutSites(v2, 1);
pat9:nac_NodesWithoutSites(v4, 1);
pat10:nac_NodesWithoutSites(v5, 0);
if { v8_p0.ix == 0; }
if { v10_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v3_p0.ix == 0; }

left:BLink;
v0_p0 -:bLink-> left;
rn0:BLink;
v10_p0 -:bLink-> rn0;
right:BLink;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
rn2:BLink;
v3_p0 -:bLink-> rn2;
replace {
v6 -c12-> v3;
v7_d39b890:SLckRef;
v7_d39b890 -:bPrnt-> v6;
v7_d39b890_p0:BPort;
v7_d39b890_p0 -c20:bNode-> v7_d39b890;
v7 -c13-> v3;
v8 -c1-> r0;
v8_p0 -c5-> v8;
v9 -c6-> v8;
v11 -c15-> v10;
v10 -c9-> v9;
v10_p0 -c14-> v10;
v13 -c16-> v10;
v12 -c19-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v14 -c17-> v10;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v15_0d71917:SLckRef;
v15_0d71917 -:bPrnt-> v13;
v15_0d71917_p0:BPort;
v15_0d71917_p0 -c21:bNode-> v15_0d71917;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
v0_p0 -:bLink-> left;
v3_p0 -:bLink-> rn2;
v10_p0 -:bLink-> rn0;
e0_3308420:BEdge;
v7_d39b890_p0 -:bLink-> e0_3308420;
v15_0d71917_p0 -:bLink-> e0_3308420;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v1, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v8 -> v8, 
v10 -> v10, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule ss_2_1 {
r0:Node; v6:SLck; v7:Mvmt; v8:Locale; v8_p0:BPort; v9:OccupiedBy; v10:Robot; v10_p0:BPort; v12:N1; v11:ID; v14:Mvmt; v13:SLck; v0:Locale; v0_p0:BPort; v1:Route; v1_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N2; 
v0 -c0:bPrnt-> r0;
v8 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v8_p0 -c5:bNode-> v8;
v9 -c6:bPrnt-> v8;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v10 -c9:bPrnt-> v9;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v7 -c13:bPrnt-> v3;
v10_p0 -c14:bNode-> v10;
v11 -c15:bPrnt-> v10;
v13 -c16:bPrnt-> v10;
v14 -c17:bPrnt-> v10;
v5 -c18:bPrnt-> v4;
v12 -c19:bPrnt-> v11;
pat0:nac_NodesWithoutSites(v6, 0);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v9, 1);
pat3:nac_NodesWithoutSites(v12, 0);
pat4:nac_NodesWithoutSites(v11, 1);
pat5:nac_NodesWithoutSites(v14, 0);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v1, 0);
pat8:nac_NodesWithoutSites(v2, 1);
pat9:nac_NodesWithoutSites(v4, 1);
pat10:nac_NodesWithoutSites(v5, 0);
if { v8_p0.ix == 0; }
if { v10_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v3_p0.ix == 0; }

left:BLink;
v0_p0 -:bLink-> left;
rn2:BLink;
v3_p0 -:bLink-> rn2;
rn1:BLink;
v10_p0 -:bLink-> rn1;
right:BLink;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
replace {
v6 -c12-> v3;
v7_0b4b542:SLckRef;
v7_0b4b542 -:bPrnt-> v6;
v7_0b4b542_p0:BPort;
v7_0b4b542_p0 -c20:bNode-> v7_0b4b542;
v7 -c13-> v3;
v8 -c1-> r0;
v8_p0 -c5-> v8;
v9 -c6-> v8;
v11 -c15-> v10;
v10 -c9-> v9;
v10_p0 -c14-> v10;
v13 -c16-> v10;
v12 -c19-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v14 -c17-> v10;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v15_6a01130:SLckRef;
v15_6a01130 -:bPrnt-> v13;
v15_6a01130_p0:BPort;
v15_6a01130_p0 -c21:bNode-> v15_6a01130;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v0_p0 -:bLink-> left;
v10_p0 -:bLink-> rn1;
v3_p0 -:bLink-> rn2;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
e0_8efe297:BEdge;
v7_0b4b542_p0 -:bLink-> e0_8efe297;
v15_6a01130_p0 -:bLink-> e0_8efe297;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v1, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v8 -> v8, 
v10 -> v10, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule ss_3_0 {
r0:Node; v6:SLck; v7:Mvmt; v8:Locale; v8_p0:BPort; v9:OccupiedBy; v10:Robot; v10_p0:BPort; v12:N0; v11:ID; v14:Mvmt; v13:SLck; v0:Locale; v0_p0:BPort; v1:Route; v1_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N3; 
v0 -c0:bPrnt-> r0;
v8 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v8_p0 -c5:bNode-> v8;
v9 -c6:bPrnt-> v8;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v10 -c9:bPrnt-> v9;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v7 -c13:bPrnt-> v3;
v10_p0 -c14:bNode-> v10;
v11 -c15:bPrnt-> v10;
v13 -c16:bPrnt-> v10;
v14 -c17:bPrnt-> v10;
v5 -c18:bPrnt-> v4;
v12 -c19:bPrnt-> v11;
pat0:nac_NodesWithoutSites(v6, 0);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v9, 1);
pat3:nac_NodesWithoutSites(v12, 0);
pat4:nac_NodesWithoutSites(v11, 1);
pat5:nac_NodesWithoutSites(v14, 0);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v1, 0);
pat8:nac_NodesWithoutSites(v2, 1);
pat9:nac_NodesWithoutSites(v4, 1);
pat10:nac_NodesWithoutSites(v5, 0);
if { v8_p0.ix == 0; }
if { v10_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v3_p0.ix == 0; }

right:BLink;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
rn3:BLink;
v3_p0 -:bLink-> rn3;
left:BLink;
v0_p0 -:bLink-> left;
rn0:BLink;
v10_p0 -:bLink-> rn0;
replace {
v6 -c12-> v3;
v7_830a548:SLckRef;
v7_830a548 -:bPrnt-> v6;
v7_830a548_p0:BPort;
v7_830a548_p0 -c20:bNode-> v7_830a548;
v7 -c13-> v3;
v8 -c1-> r0;
v8_p0 -c5-> v8;
v9 -c6-> v8;
v11 -c15-> v10;
v10 -c9-> v9;
v10_p0 -c14-> v10;
v13 -c16-> v10;
v12 -c19-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v14 -c17-> v10;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v15_4868585:SLckRef;
v15_4868585 -:bPrnt-> v13;
v15_4868585_p0:BPort;
v15_4868585_p0 -c21:bNode-> v15_4868585;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v10_p0 -:bLink-> rn0;
v0_p0 -:bLink-> left;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
v3_p0 -:bLink-> rn3;
e0_f27f147:BEdge;
v7_830a548_p0 -:bLink-> e0_f27f147;
v15_4868585_p0 -:bLink-> e0_f27f147;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v1, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v8 -> v8, 
v10 -> v10, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule ss_3_1 {
r0:Node; v6:SLck; v7:Mvmt; v8:Locale; v8_p0:BPort; v9:OccupiedBy; v10:Robot; v10_p0:BPort; v12:N1; v11:ID; v14:Mvmt; v13:SLck; v0:Locale; v0_p0:BPort; v1:Route; v1_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N3; 
v0 -c0:bPrnt-> r0;
v8 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v8_p0 -c5:bNode-> v8;
v9 -c6:bPrnt-> v8;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v10 -c9:bPrnt-> v9;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v7 -c13:bPrnt-> v3;
v10_p0 -c14:bNode-> v10;
v11 -c15:bPrnt-> v10;
v13 -c16:bPrnt-> v10;
v14 -c17:bPrnt-> v10;
v5 -c18:bPrnt-> v4;
v12 -c19:bPrnt-> v11;
pat0:nac_NodesWithoutSites(v6, 0);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v9, 1);
pat3:nac_NodesWithoutSites(v12, 0);
pat4:nac_NodesWithoutSites(v11, 1);
pat5:nac_NodesWithoutSites(v14, 0);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v1, 0);
pat8:nac_NodesWithoutSites(v2, 1);
pat9:nac_NodesWithoutSites(v4, 1);
pat10:nac_NodesWithoutSites(v5, 0);
if { v8_p0.ix == 0; }
if { v10_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v3_p0.ix == 0; }

rn3:BLink;
v3_p0 -:bLink-> rn3;
rn1:BLink;
v10_p0 -:bLink-> rn1;
right:BLink;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
left:BLink;
v0_p0 -:bLink-> left;
replace {
v6 -c12-> v3;
v7_4e7951:SLckRef;
v7_4e7951 -:bPrnt-> v6;
v7_4e7951_p0:BPort;
v7_4e7951_p0 -c20:bNode-> v7_4e7951;
v7 -c13-> v3;
v8 -c1-> r0;
v8_p0 -c5-> v8;
v9 -c6-> v8;
v11 -c15-> v10;
v10 -c9-> v9;
v10_p0 -c14-> v10;
v13 -c16-> v10;
v12 -c19-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v14 -c17-> v10;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v15_e2cc818:SLckRef;
v15_e2cc818 -:bPrnt-> v13;
v15_e2cc818_p0:BPort;
v15_e2cc818_p0 -c21:bNode-> v15_e2cc818;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v10_p0 -:bLink-> rn1;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
v3_p0 -:bLink-> rn3;
v0_p0 -:bLink-> left;
e0_57da317:BEdge;
v7_4e7951_p0 -:bLink-> e0_57da317;
v15_e2cc818_p0 -:bLink-> e0_57da317;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v1, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v8 -> v8, 
v10 -> v10, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule ss_3_2 {
r0:Node; v6:SLck; v7:Mvmt; v8:Locale; v8_p0:BPort; v9:OccupiedBy; v10:Robot; v10_p0:BPort; v12:N2; v11:ID; v14:Mvmt; v13:SLck; v0:Locale; v0_p0:BPort; v1:Route; v1_p0:BPort; v2:OccupiedBy; v3:Robot; v3_p0:BPort; v4:ID; v5:N3; 
v0 -c0:bPrnt-> r0;
v8 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v2 -c4:bPrnt-> v0;
v8_p0 -c5:bNode-> v8;
v9 -c6:bPrnt-> v8;
v1_p0 -c7:bNode-> v1;
v3 -c8:bPrnt-> v2;
v10 -c9:bPrnt-> v9;
v3_p0 -c10:bNode-> v3;
v4 -c11:bPrnt-> v3;
v6 -c12:bPrnt-> v3;
v7 -c13:bPrnt-> v3;
v10_p0 -c14:bNode-> v10;
v11 -c15:bPrnt-> v10;
v13 -c16:bPrnt-> v10;
v14 -c17:bPrnt-> v10;
v5 -c18:bPrnt-> v4;
v12 -c19:bPrnt-> v11;
pat0:nac_NodesWithoutSites(v6, 0);
pat1:nac_NodesWithoutSites(v7, 0);
pat2:nac_NodesWithoutSites(v9, 1);
pat3:nac_NodesWithoutSites(v12, 0);
pat4:nac_NodesWithoutSites(v11, 1);
pat5:nac_NodesWithoutSites(v14, 0);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v1, 0);
pat8:nac_NodesWithoutSites(v2, 1);
pat9:nac_NodesWithoutSites(v4, 1);
pat10:nac_NodesWithoutSites(v5, 0);
if { v8_p0.ix == 0; }
if { v10_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v3_p0.ix == 0; }

left:BLink;
v0_p0 -:bLink-> left;
rn3:BLink;
v3_p0 -:bLink-> rn3;
right:BLink;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
rn2:BLink;
v10_p0 -:bLink-> rn2;
replace {
v6 -c12-> v3;
v7_d27c826:SLckRef;
v7_d27c826 -:bPrnt-> v6;
v7_d27c826_p0:BPort;
v7_d27c826_p0 -c20:bNode-> v7_d27c826;
v7 -c13-> v3;
v8 -c1-> r0;
v8_p0 -c5-> v8;
v9 -c6-> v8;
v11 -c15-> v10;
v10 -c9-> v9;
v10_p0 -c14-> v10;
v13 -c16-> v10;
v12 -c19-> v11;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v14 -c17-> v10;
v1 -c3-> v0;
v1_p0 -c7-> v1;
v15_fbd3940:SLckRef;
v15_fbd3940 -:bPrnt-> v13;
v15_fbd3940_p0:BPort;
v15_fbd3940_p0 -c21:bNode-> v15_fbd3940;
v2 -c4-> v0;
v3 -c8-> v2;
v3_p0 -c10-> v3;
v4 -c11-> v3;
v5 -c18-> v4;
v0_p0 -:bLink-> left;
v8_p0 -:bLink-> right;
v1_p0 -:bLink-> right;
v10_p0 -:bLink-> rn2;
e0_15bd280:BEdge;
v7_d27c826_p0 -:bLink-> e0_15bd280;
v15_fbd3940_p0 -:bLink-> e0_15bd280;
v3_p0 -:bLink-> rn3;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v1, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v8 -> v8, 
v10 -> v10, 
v0 -> v0, 
v3 -> v3 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule initMvmt {
r0:Node; v6:OccupiedBy; v7:Locale; v7_p0:BPort; v8:Route; v8_p0:BPort; v9:OccupiedBy; v10:Robot; v10_p0:BPort; v12:SLckRef; v12_p0:BPort; v11:SLck; v14:Locale; v14_p0:BPort; v13:Mvmt; v0:Locale; v0_p0:BPort; v16:Robot; v16_p0:BPort; v1:Route; v1_p0:BPort; v15:OccupiedBy; v2:Route; v2_p0:BPort; v18:SLckRef; v18_p0:BPort; v3:OccupiedBy; v17:SLck; v4:Locale; v4_p0:BPort; v5:Route; v5_p0:BPort; v19:Mvmt; 
v0 -c0:bPrnt-> r0;
v4 -c1:bPrnt-> r0;
v7 -c2:bPrnt-> r0;
v14 -c3:bPrnt-> r0;
v0_p0 -c4:bNode-> v0;
v1 -c5:bPrnt-> v0;
v2 -c6:bPrnt-> v0;
v3 -c7:bPrnt-> v0;
v4_p0 -c8:bNode-> v4;
v5 -c9:bPrnt-> v4;
v6 -c10:bPrnt-> v4;
v7_p0 -c11:bNode-> v7;
v8 -c12:bPrnt-> v7;
v9 -c13:bPrnt-> v7;
v14_p0 -c14:bNode-> v14;
v15 -c15:bPrnt-> v14;
v1_p0 -c16:bNode-> v1;
v2_p0 -c17:bNode-> v2;
v5_p0 -c18:bNode-> v5;
v8_p0 -c19:bNode-> v8;
v10 -c20:bPrnt-> v9;
v16 -c21:bPrnt-> v15;
v10_p0 -c22:bNode-> v10;
v11 -c23:bPrnt-> v10;
v13 -c24:bPrnt-> v10;
v16_p0 -c25:bNode-> v16;
v17 -c26:bPrnt-> v16;
v19 -c27:bPrnt-> v16;
v12 -c28:bPrnt-> v11;
v18 -c29:bPrnt-> v17;
v12_p0 -c30:bNode-> v12;
v18_p0 -c31:bNode-> v18;
pat0:nac_NodesWithoutSites(v6, 0);
pat1:nac_NodesWithoutSites(v7, 2);
pat2:nac_NodesWithoutSites(v8, 0);
pat3:nac_NodesWithoutSites(v9, 1);
pat4:nac_NodesWithoutSites(v12, 0);
pat5:nac_NodesWithoutSites(v11, 1);
pat6:nac_NodesWithoutSites(v13, 0);
pat7:nac_NodesWithoutSites(v0, 3);
pat8:nac_NodesWithoutSites(v1, 0);
pat9:nac_NodesWithoutSites(v15, 1);
pat10:nac_NodesWithoutSites(v2, 0);
pat11:nac_NodesWithoutSites(v18, 0);
pat12:nac_NodesWithoutSites(v3, 0);
pat13:nac_NodesWithoutSites(v17, 1);
pat14:nac_NodesWithoutSites(v5, 0);
pat15:nac_NodesWithoutSites(v19, 0);
if { v7_p0.ix == 0; }
if { v8_p0.ix == 0; }
if { v10_p0.ix == 0; }
if { v12_p0.ix == 0; }
if { v14_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v16_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v2_p0.ix == 0; }
if { v18_p0.ix == 0; }
if { v4_p0.ix == 0; }
if { v5_p0.ix == 0; }

y1:BLink;
v4_p0 -:bLink-> y1;
v1_p0 -:bLink-> y1;
y3:BLink;
v14_p0 -:bLink-> y3;
v5_p0 -:bLink-> y3;
v8_p0 -:bLink-> y3;
y0:BLink;
v0_p0 -:bLink-> y0;
e0:BEdge;
v12_p0 -:bLink-> e0;
v18_p0 -:bLink-> e0;
n_right:BLink;
v16_p0 -:bLink-> n_right;
n_left:BLink;
v10_p0 -:bLink-> n_left;
y2:BLink;
v7_p0 -:bLink-> y2;
v2_p0 -:bLink-> y2;
replace {
v4 -c1-> r0;
v4_p0 -c8-> v4;
v5 -c9-> v4;
v5_p0 -c18-> v5;
v8_b066235:WayPoint;
v8_b066235 -:bPrnt-> v4;
v8_b066235_p0:BPort;
v8_b066235_p0 -c32:bNode-> v8_b066235;
v9_a05c924:SLckRef;
v9_a05c924 -:bPrnt-> v8_b066235;
v9_a05c924_p0:BPort;
v9_a05c924_p0 -c33:bNode-> v9_a05c924;
v30_ced3491:Token;
v30_ced3491 -:bPrnt-> v19;
v6 -c10-> v4;
v31_cf1b114:Token;
v31_cf1b114 -:bPrnt-> v19;
v8 -c12-> v7;
v8_p0 -c19-> v8;
v7 -c2-> r0;
v7_p0 -c11-> v7;
v14_5cde330:SLckRef;
v14_5cde330 -:bPrnt-> v13_cae1632;
v14_5cde330_p0:BPort;
v14_5cde330_p0 -c34:bNode-> v14_5cde330;
v13_cae1632:WayPoint;
v13_cae1632 -:bPrnt-> v7;
v13_cae1632_p0:BPort;
v13_cae1632_p0 -c35:bNode-> v13_cae1632;
v10 -c20-> v9;
v10_p0 -c22-> v10;
v9 -c13-> v7;
v12 -c28-> v11;
v12_p0 -c30-> v12;
v11 -c23-> v10;
v13 -c24-> v10;
v14 -c3-> r0;
v14_p0 -c14-> v14;
v20_1617261:Token;
v20_1617261 -:bPrnt-> v13;
v23_03d7771:SLckRef;
v23_03d7771 -:bPrnt-> v22_fe1d518;
v23_03d7771_p0:BPort;
v23_03d7771_p0 -c36:bNode-> v23_03d7771;
v22_fe1d518:WayPoint;
v22_fe1d518 -:bPrnt-> v14;
v22_fe1d518_p0:BPort;
v22_fe1d518_p0 -c37:bNode-> v22_fe1d518;
v16 -c21-> v15;
v16_p0 -c25-> v16;
v15 -c15-> v14;
v0 -c0-> r0;
v0_p0 -c4-> v0;
v18 -c29-> v17;
v18_p0 -c31-> v18;
v1 -c5-> v0;
v1_p0 -c16-> v1;
v17 -c26-> v16;
v2 -c6-> v0;
v2_p0 -c17-> v2;
v29_abc3403:Token;
v29_abc3403 -:bPrnt-> v19;
v3_5d26115:WayPoint;
v3_5d26115 -:bPrnt-> v0;
v3_5d26115_p0:BPort;
v3_5d26115_p0 -c38:bNode-> v3_5d26115;
v19 -c27-> v16;
v4_a725416:SLckRef;
v4_a725416 -:bPrnt-> v3_5d26115;
v4_a725416_p0:BPort;
v4_a725416_p0 -c39:bNode-> v4_a725416;
v3 -c7-> v0;
v7_p0 -:bLink-> y2;
v2_p0 -:bLink-> y2;
v3_5d26115_p0 -:bLink-> y2;
v4_p0 -:bLink-> y1;
v22_fe1d518_p0 -:bLink-> y1;
v1_p0 -:bLink-> y1;
v12_p0 -:bLink-> e0;
v18_p0 -:bLink-> e0;
v9_a05c924_p0 -:bLink-> n_right;
v23_03d7771_p0 -:bLink-> n_right;
v16_p0 -:bLink-> n_right;
v4_a725416_p0 -:bLink-> n_right;
v14_5cde330_p0 -:bLink-> n_left;
v10_p0 -:bLink-> n_left;
v5_p0 -:bLink-> y3;
v8_p0 -:bLink-> y3;
v13_cae1632_p0 -:bLink-> y3;
v14_p0 -:bLink-> y3;
v8_b066235_p0 -:bLink-> y0;
v0_p0 -:bLink-> y0;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v12, v11, v14, v13, v0, v16, v1, v15, v2, v18, v3, v17, r0, v4, v5, v19};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v10 -> v10, 
v14 -> v14, 
v16 -> v16, 
v4 -> v4 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
rule move {
r0:Node; v6:SLckRef; v6_p0:BPort; v7:Mvmt; v8:Token; v9:Locale; v9_p0:BPort; v10:OccupiedBy; v0:Locale; v0_p0:BPort; v1:WayPoint; v1_p0:BPort; v2:SLckRef; v2_p0:BPort; v3:OccupiedBy; v4:Robot; v4_p0:BPort; v5:SLck; 
v0 -c0:bPrnt-> r0;
v9 -c1:bPrnt-> r0;
v0_p0 -c2:bNode-> v0;
v1 -c3:bPrnt-> v0;
v3 -c4:bPrnt-> v0;
v9_p0 -c5:bNode-> v9;
v10 -c6:bPrnt-> v9;
v1_p0 -c7:bNode-> v1;
v2 -c8:bPrnt-> v1;
v4 -c9:bPrnt-> v3;
v2_p0 -c10:bNode-> v2;
v4_p0 -c11:bNode-> v4;
v5 -c12:bPrnt-> v4;
v7 -c13:bPrnt-> v4;
v6 -c14:bPrnt-> v5;
v8 -c15:bPrnt-> v7;
v6_p0 -c16:bNode-> v6;
pat0:nac_NodesWithoutSites(v6, 0);
pat1:nac_NodesWithoutSites(v8, 0);
pat2:nac_NodesWithoutSites(v10, 0);
pat3:nac_NodesWithoutSites(v1, 1);
pat4:nac_NodesWithoutSites(v2, 0);
pat5:nac_NodesWithoutSites(v3, 1);
pat6:nac_NodesWithoutSites(v5, 1);
if { v6_p0.ix == 0; }
if { v9_p0.ix == 0; }
if { v0_p0.ix == 0; }
if { v1_p0.ix == 0; }
if { v2_p0.ix == 0; }
if { v4_p0.ix == 0; }

tgt:BLink;
v9_p0 -:bLink-> tgt;
v1_p0 -:bLink-> tgt;
ref:BLink;
v6_p0 -:bLink-> ref;
n_id:BLink;
v2_p0 -:bLink-> n_id;
v4_p0 -:bLink-> n_id;
src:BLink;
v0_p0 -:bLink-> src;
replace {
v6 -c14-> v5;
v6_p0 -c16-> v6;
v7 -c13-> v4;
v0 -c0-> r0;
v0_p0 -c2-> v0;
v3 -c4-> v0;
v9 -c1-> r0;
v9_p0 -c5-> v9;
v10 -c6-> v9;
v4 -:bPrnt-> v10;
v4_p0 -c11-> v4;
v5 -c12-> v4;
v6_p0 -:bLink-> ref;
v4_p0 -:bLink-> n_id;
v0_p0 -:bLink-> src;
v9_p0 -:bLink-> tgt;

---

def ref allMatchedNodes:set<Node> = set<Node>{v6, v7, v8, v9, v10, v0, v1, v2, v3, r0, v4, v5};
def ref indexMap:map<Node,Node> = map<Node,Node>{
v7 -> v7, 
v9 -> v9, 
v0 -> v0, 
v4 -> v4 
};
def ref tasks:map<Edge,Node> = map<Edge,Node>{};
eval {

def ref nodesWithSites:set<Node> = indexMap.domain();
for(cur:Node in nodesWithSites) {
    emit(cur, "->", indexMap[cur], " ", countAdjacentIncoming(cur), "\n");
    if(indexMap[cur] == null) {
        emit("Remove everything because there is no site mapping for the reactum", adjacentIncoming(cur), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort) {
                rem(x__INTERN);
            }
        }
        continue;
    }
    if(cur != indexMap[cur]) {
        emit("Site mappings are different! Size of children: ", adjacentIncoming(cur).size(), "\n");
        for(x__INTERN:Node in adjacentIncoming(cur)) {
            if(typeof(x__INTERN) != BPort && !(x__INTERN in allMatchedNodes)) {
                emit("\tchild = ", x__INTERN, " ", typeof(x__INTERN), " ", indexMap[cur], " ", outgoing(x__INTERN), "\n");
                for(y:Edge in outgoing(x__INTERN)) {
                    if(typeof(y) == bPrnt) {
                        /// Get new parent node: indexMap[cur] and redirect edge, is better than adding and removing edge
                        emit("\ty", y, " ", typeof(y), " ", nameof(y), "\n");
                        ///redirectTarget(y, indexMap[cur]);
                        tasks.add(y, indexMap[cur]);
                        ///rem(y);
                    }
                }
                ///add(bPrnt, x__INTERN, indexMap[cur]);
            }
        }
    }
}
def ref keyset:set<Edge> = tasks.domain();
for(k:Edge in keyset) {
   redirectTarget(k, tasks[k]);
}


}
}
}
